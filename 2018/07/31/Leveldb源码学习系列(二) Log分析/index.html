<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Leveldb源码学习系列(二) Log分析 | DOROTHY</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Dorothy Zhang">
  
  
    <meta name="description" content="Leveldb在将数据写入memtable之前会首先进行WAL操作，即记录日志。这样即使内存中的数据丢失，也可以即使恢复过来。本节将分析Log的写入和读取过程。
1. Log文件的格式Leveldb的log文件以block为单位进行划分，每个block的大小默认为32KB，每个block中存储了多个record，一个record就是一条记录操作。record的格式为：
checksum(4B) |">
  
  <meta name="description" content="Leveldb在将数据写入memtable之前会首先进行WAL操作，即记录日志。这样即使内存中的数据丢失，也可以即使恢复过来。本节将分析Log的写入和读取过程。
1. Log文件的格式Leveldb的log文件以block为单位进行划分，每个block的大小默认为32KB，每个block中存储了多个record，一个record就是一条记录操作。record的格式为：
checksum(4B) |">
<meta property="og:type" content="article">
<meta property="og:title" content="Leveldb源码学习系列(二) Log分析">
<meta property="og:url" content="http://yoursite.com/2018/07/31/Leveldb源码学习系列(二) Log分析/index.html">
<meta property="og:site_name" content="DOROTHY">
<meta property="og:description" content="Leveldb在将数据写入memtable之前会首先进行WAL操作，即记录日志。这样即使内存中的数据丢失，也可以即使恢复过来。本节将分析Log的写入和读取过程。
1. Log文件的格式Leveldb的log文件以block为单位进行划分，每个block的大小默认为32KB，每个block中存储了多个record，一个record就是一条记录操作。record的格式为：
checksum(4B) |">
<meta property="og:updated_time" content="2018-07-31T15:49:44.068Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leveldb源码学习系列(二) Log分析">
<meta name="twitter:description" content="Leveldb在将数据写入memtable之前会首先进行WAL操作，即记录日志。这样即使内存中的数据丢失，也可以即使恢复过来。本节将分析Log的写入和读取过程。
1. Log文件的格式Leveldb的log文件以block为单位进行划分，每个block的大小默认为32KB，每个block中存储了多个record，一个record就是一条记录操作。record的格式为：
checksum(4B) |">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <header id="header">
  <div class="title-wrapper">
    <div class="title">
      <h1><a href="/">DOROTHY</a></h1>
      <p><a href="/"></a></p>
    </div>
  </div>
</header>
<nav class="nav">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
    
  </ul>
</nav>

  <div class="wrapper">
    <div class="content"><article class="post">
  <header>
    
  
    <h1 class="title">Leveldb源码学习系列(二) Log分析</h1>
  

    
      <a href="/2018/07/31/Leveldb源码学习系列(二) Log分析/">
  <time datetime="2018-07-31T15:49:11.000Z">
    2018-07-31
  </time>
</a>
    
  </header>
  
  <div class="entry">
    
      <p>Leveldb在将数据写入memtable之前会首先进行WAL操作，即记录日志。这样即使内存中的数据丢失，也可以即使恢复过来。本节将分析Log的写入和读取过程。</p>
<h3 id="1-_Log文件的格式">1. Log文件的格式</h3><p>Leveldb的log文件以block为单位进行划分，每个block的大小默认为32KB，每个block中存储了多个record，一个record就是一条记录操作。record的格式为：</p>
<p>checksum(4B) | length(2B) | type(1B) | data</p>
<p>其中type有5种类型，分别为：</p>
<ul>
<li>kZeroType </li>
<li>kFullType </li>
<li>kFirstType</li>
<li>kMiddleType</li>
<li>kLastType</li>
</ul>
<p>如果一条记录的大小小于32KB，那么就可以存放在一个block中，该条记录类型就是kFullType；如果记录在一个block中放不下，那么就要拆分成多个record进行存放，其中第一个record的type是kFirstType，中间的是kMiddleType，最后一个record的类型是kLastType。</p>
<h3 id="2-_Log文件的写过程">2. Log文件的写过程</h3><p>读log主要涉及两个文件：</p>
<p>log_writer.h</p>
<p>log_writer.cc</p>
<p>首先看下log_writer的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Writer &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile* dest)</span></span>;</span><br><span class="line">  ~Writer();</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  WritableFile* dest_;</span><br><span class="line">  <span class="keyword">int</span> block_offset_;       <span class="comment">// Current offset in block</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>];</span><br><span class="line">  <span class="function">Status <span class="title">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, size_t length)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  Writer(<span class="keyword">const</span> Writer&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Writer&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Writer类主要负责将数据写入日志文件中，可以看到其接口非常简单，就是<code>Status</code>,下面我们来分析一下这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Status Writer::AddRecord(<span class="keyword">const</span> Slice&amp; slice) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="keyword">size_t</span> left = slice.size();</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> begin = <span class="literal">true</span>; <span class="comment">// 写第一个record</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_; <span class="comment">// 当前block还剩下多少剩余空间</span></span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123; <span class="comment">// 如果剩余空间小于7，就从下一个block开始写，同时将余下的空间填充0</span></span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        assert(kHeaderSize == <span class="number">7</span>);</span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>; <span class="comment">// 新的block，重置block_offset_</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize; <span class="comment">// 去除headersize实际可以写入数据的大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail; <span class="comment">//当前块最大可以写入多少数据</span></span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> end = (left == fragment_length);<span class="comment">// 如果数据可以完全写入当前块</span></span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123; <span class="comment">// end为false，说明数据不能完全写入当前块，第一条record类型为first</span></span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123; </span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length); <span class="comment">// 实际的写入操作</span></span><br><span class="line">    ptr += fragment_length; <span class="comment">// 移动指针到数据还没写入的地方</span></span><br><span class="line">    left -= fragment_length; <span class="comment">// 还需要写入数据的长度</span></span><br><span class="line">    begin = <span class="literal">false</span>;  <span class="comment">// 已经至少写入一个record了，再写时当前块就不是first了</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>); <span class="comment">// 循环，直到数据写完</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status Writer::EmitPhysicalRecord(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">  assert(n &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header 首先将头数据写入record</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, n);</span><br><span class="line">  crc = crc32c::Mask(crc);                 <span class="comment">// Adjust for storage</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, n));</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + n;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>AddRecord(const Slice&amp; slice)</code>接口的实现还是比较简单的，就是按照块大小，循环将record写入，如果块大小不够写入一条record了，就开辟一个新的record。</p>
<h3 id="3-_Log文件的读过程">3. Log文件的读过程</h3><p>读过程相对于写过程要复杂一些。读日志时，是以块为单位进行读取的，程序会循环读取块，直到读取到一条完整的record。下面看下log_reader接口文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Reader &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Interface for reporting errors.</span></span><br><span class="line">  <span class="keyword">class</span> Reporter &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Reporter();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(size_t bytes, <span class="keyword">const</span> Status&amp; status)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  Reader(SequentialFile* file, Reporter* reporter, <span class="keyword">bool</span> checksum,</span><br><span class="line">         <span class="keyword">uint64_t</span> initial_offset);</span><br><span class="line"></span><br><span class="line">  ~Reader();</span><br><span class="line">  <span class="comment">// 读取记录的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ReadRecord</span><span class="params">(Slice* record, <span class="built_in">std</span>::<span class="built_in">string</span>* scratch)</span></span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> LastRecordOffset();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  SequentialFile* <span class="keyword">const</span> file_;</span><br><span class="line">  Reporter* <span class="keyword">const</span> reporter_;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">const</span> checksum_; <span class="comment">// 是否需要crc校验</span></span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> backing_store_;  <span class="comment">// 实际存放数据的地方</span></span><br><span class="line">  Slice buffer_;</span><br><span class="line">  <span class="comment">// 是否到达一个block的尾部</span></span><br><span class="line">  <span class="keyword">bool</span> eof_;   <span class="comment">// Last Read() indicated EOF by returning &lt; kBlockSize</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Offset of the last record returned by ReadRecord.</span></span><br><span class="line">  <span class="keyword">uint64_t</span> last_record_offset_; <span class="comment">// 上一个读取的record的起始偏移</span></span><br><span class="line">  <span class="comment">// Offset of the first location past the end of buffer_.</span></span><br><span class="line">  <span class="keyword">uint64_t</span> end_of_buffer_offset_; <span class="comment">//最后读取到的buffer的终点偏移</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Offset at which to start looking for the first record to return</span></span><br><span class="line">  <span class="keyword">uint64_t</span> <span class="keyword">const</span> initial_offset_; <span class="comment">// 起始偏移</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Extend record types with the following special values</span></span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    kEof = kMaxRecordType + <span class="number">1</span>,</span><br><span class="line">    kBadRecord = kMaxRecordType + <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skips all blocks that are completely before "initial_offset_".</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns true on success. Handles reporting.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SkipToInitialBlock</span><span class="params">()</span></span>; <span class="comment">// seek到要读取的block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return type, or one of the preceding special values</span></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ReadPhysicalRecord</span><span class="params">(Slice* result)</span></span>; <span class="comment">// 实际读数据的地方，以块为单位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reports dropped bytes to the reporter.</span></span><br><span class="line">  <span class="comment">// buffer_ must be updated to remove the dropped bytes prior to invocation.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReportCorruption</span><span class="params">(uint64_t bytes, <span class="keyword">const</span> <span class="keyword">char</span>* reason)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReportDrop</span><span class="params">(uint64_t bytes, <span class="keyword">const</span> Status&amp; reason)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  Reader(<span class="keyword">const</span> Reader&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Reader&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出读日志主要在两个函数中进行：<code>bool ReadRecord(Slice* record, std::string* scratch)</code>和<code>ReadPhysicalRecord(Slice* result)</code>, 下面着重分析下这两个函数。在开始前，还是先看下<code>SkipToInitialBlock()</code>这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Reader::SkipToInitialBlock() &#123;</span><br><span class="line">  <span class="keyword">size_t</span> offset_in_block = initial_offset_ % kBlockSize; <span class="comment">// 块内偏移</span></span><br><span class="line">  <span class="keyword">uint64_t</span> block_start_location = initial_offset_ - offset_in_block; <span class="comment">// 起始块地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don't search a block if we'd be in the trailer</span></span><br><span class="line">  <span class="keyword">if</span> (offset_in_block &gt; kBlockSize - <span class="number">6</span>) &#123; <span class="comment">// 如果块内偏移太大，导致不够存放记录头，直接跳过该块</span></span><br><span class="line">    offset_in_block = <span class="number">0</span>;</span><br><span class="line">    block_start_location += kBlockSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  end_of_buffer_offset_ = block_start_location;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip to start of first block that can contain the initial record</span></span><br><span class="line">  <span class="keyword">if</span> (block_start_location &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Status skip_status = file_-&gt;Skip(block_start_location); <span class="comment">// 移动到块起始地址</span></span><br><span class="line">    <span class="keyword">if</span> (!skip_status.ok()) &#123;</span><br><span class="line">      ReportDrop(block_start_location, skip_status);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>SkipToInitialBlock()</code>就是将文件指针seek到指定的偏移位置，为后面的读取做准备。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Reader::ReadRecord(Slice* record, <span class="built_in">std</span>::<span class="built_in">string</span>* scratch) &#123;</span><br><span class="line">  <span class="keyword">if</span> (last_record_offset_ &lt; initial_offset_) &#123; <span class="comment">// 上一次读取记录的起始偏移小于initial_offset_</span></span><br><span class="line">    <span class="keyword">if</span> (!SkipToInitialBlock()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scratch-&gt;clear();</span><br><span class="line">  record-&gt;clear();</span><br><span class="line">  <span class="keyword">bool</span> in_fragmented_record = <span class="literal">false</span>; <span class="comment">// 一个记录是否在多个record中，用于校验记录的完整性</span></span><br><span class="line">  <span class="comment">// Record offset of the logical record that we're reading</span></span><br><span class="line">  <span class="comment">// 0 is a dummy value to make compilers happy</span></span><br><span class="line">  <span class="keyword">uint64_t</span> prospective_record_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> physical_record_offset = end_of_buffer_offset_ - buffer_.size();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> record_type = ReadPhysicalRecord(&amp;fragment); <span class="comment">//读取一条记录到fragment中</span></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType: <span class="comment">// 如果记录类型是fulltype，那么就读取完了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// Handle bug in earlier versions of log::Writer where</span></span><br><span class="line">          <span class="comment">// it could emit an empty kFirstType record at the tail end</span></span><br><span class="line">          <span class="comment">// of a block followed by a kFullType or kFirstType record</span></span><br><span class="line">          <span class="comment">// at the beginning of the next block.</span></span><br><span class="line">          <span class="keyword">if</span> (scratch-&gt;empty()) &#123;</span><br><span class="line">            in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ReportCorruption(scratch-&gt;size(), <span class="string">"partial record without end(1)"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prospective_record_offset = physical_record_offset;</span><br><span class="line">        scratch-&gt;clear();</span><br><span class="line">        *record = fragment;</span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// Handle bug in earlier versions of log::Writer where</span></span><br><span class="line">          <span class="comment">// it could emit an empty kFirstType record at the tail end</span></span><br><span class="line">          <span class="comment">// of a block followed by a kFullType or kFirstType record</span></span><br><span class="line">          <span class="comment">// at the beginning of the next block.</span></span><br><span class="line">          <span class="keyword">if</span> (scratch-&gt;empty()) &#123;</span><br><span class="line">            in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ReportCorruption(scratch-&gt;size(), <span class="string">"partial record without end(2)"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prospective_record_offset = physical_record_offset;</span><br><span class="line">        scratch-&gt;assign(fragment.data(), fragment.size());</span><br><span class="line">        in_fragmented_record = <span class="literal">true</span>; <span class="comment">// 不是一条完整的记录</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          ReportCorruption(fragment.size(),</span><br><span class="line">                           <span class="string">"missing start of fragmented record(1)"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;append(fragment.data(), fragment.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kLastType: <span class="comment">// 类型为lasttype，读取完毕</span></span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          ReportCorruption(fragment.size(),</span><br><span class="line">                           <span class="string">"missing start of fragmented record(2)"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;append(fragment.data(), fragment.size());</span><br><span class="line">          *record = Slice(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kEof:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// This can be caused by the writer dying immediately after</span></span><br><span class="line">          <span class="comment">// writing a physical record but before completing the next; don't</span></span><br><span class="line">          <span class="comment">// treat it as a corruption, just ignore the entire logical record.</span></span><br><span class="line">          scratch-&gt;clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kBadRecord:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          ReportCorruption(scratch-&gt;size(), <span class="string">"error in middle of record"</span>);</span><br><span class="line">          in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">          scratch-&gt;clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"unknown record type %u"</span>, record_type);</span><br><span class="line">        ReportCorruption(</span><br><span class="line">            (fragment.size() + (in_fragmented_record ? scratch-&gt;size() : <span class="number">0</span>)),</span><br><span class="line">            buf);</span><br><span class="line">        in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">        scratch-&gt;clear();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>bool ReadRecord(Slice* record, std::string* scratch)</code>也是比较简单的，就是循环用<code>ReadPhysicalRecord(&amp;fragment)</code>读取一条记录，然后判断该条记录是否是完整的，不是就继续循环读，直到将一条完整的记录读完为止。</p>
<p>下面我们看下<code>ReadPhysicalRecord(&amp;fragment)</code>里的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Reader::ReadPhysicalRecord(Slice* result) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer_.size() &lt; kHeaderSize) &#123; <span class="comment">// 该条件在两种情况下会成立，一种是第一次读，buffer.size()=0 , 另一种是ReadRecord()循环了多次，剩余的buffer内容是block的尾部，没有存放record，如果buffer.size()大于kHeaderSize，说明还有记录，不用读文件，直接跳转到后面的流程。</span></span><br><span class="line">      <span class="keyword">if</span> (!eof_) &#123;  <span class="comment">// 第一次读没有到达文件尾</span></span><br><span class="line">        <span class="comment">// Last read was a full read, so this is a trailer to skip</span></span><br><span class="line">        buffer_.clear();</span><br><span class="line">        Status status = file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_); <span class="comment">// 读取一个block的数据到buffer中</span></span><br><span class="line">        end_of_buffer_offset_ += buffer_.size();</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          buffer_.clear();</span><br><span class="line">          ReportDrop(kBlockSize, status);</span><br><span class="line">          eof_ = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> kEof;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer_.size() &lt; kBlockSize) &#123; <span class="comment">// 如果读到的内容小于一个block的size，说明读出错了</span></span><br><span class="line">          eof_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note that if buffer_ is non-empty, we have a truncated header at the</span></span><br><span class="line">        <span class="comment">// end of the file, which can be caused by the writer crashing in the</span></span><br><span class="line">        <span class="comment">// middle of writing the header. Instead of considering this an error,</span></span><br><span class="line">        <span class="comment">// just report EOF.</span></span><br><span class="line">        buffer_.clear();  <span class="comment">// 到达文件尾了</span></span><br><span class="line">        <span class="keyword">return</span> kEof;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the header  一个block的前7个字节一定是第一个record的头，将其解析出来</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* header = buffer_.data();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> a = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> type = header[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (kHeaderSize + length &gt; buffer_.size()) &#123; <span class="comment">// 校验</span></span><br><span class="line">      <span class="keyword">size_t</span> drop_size = buffer_.size();</span><br><span class="line">      buffer_.clear();</span><br><span class="line">      <span class="keyword">if</span> (!eof_) &#123;</span><br><span class="line">        ReportCorruption(drop_size, <span class="string">"bad record length"</span>);</span><br><span class="line">        <span class="keyword">return</span> kBadRecord;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If the end of the file has been reached without reading |length| bytes</span></span><br><span class="line">      <span class="comment">// of payload, assume the writer died in the middle of writing the record.</span></span><br><span class="line">      <span class="comment">// Don't report a corruption.</span></span><br><span class="line">      <span class="keyword">return</span> kEof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == kZeroType &amp;&amp; length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Skip zero length record without reporting any drops since</span></span><br><span class="line">      <span class="comment">// such records are produced by the mmap based writing code in</span></span><br><span class="line">      <span class="comment">// env_posix.cc that preallocates file regions.</span></span><br><span class="line">      buffer_.clear();</span><br><span class="line">      <span class="keyword">return</span> kBadRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check crc</span></span><br><span class="line">    <span class="keyword">if</span> (checksum_) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> expected_crc = crc32c::Unmask(DecodeFixed32(header));</span><br><span class="line">      <span class="keyword">uint32_t</span> actual_crc = crc32c::Value(header + <span class="number">6</span>, <span class="number">1</span> + length);</span><br><span class="line">      <span class="keyword">if</span> (actual_crc != expected_crc) &#123;</span><br><span class="line">        <span class="comment">// Drop the rest of the buffer since "length" itself may have</span></span><br><span class="line">        <span class="comment">// been corrupted and if we trust it, we could find some</span></span><br><span class="line">        <span class="comment">// fragment of a real log record that just happens to look</span></span><br><span class="line">        <span class="comment">// like a valid log record.</span></span><br><span class="line">        <span class="keyword">size_t</span> drop_size = buffer_.size();</span><br><span class="line">        buffer_.clear();</span><br><span class="line">        ReportCorruption(drop_size, <span class="string">"checksum mismatch"</span>);</span><br><span class="line">        <span class="keyword">return</span> kBadRecord;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer_.remove_prefix(kHeaderSize + length);  <span class="comment">// 本次record的长度为kHeaderSize + length， 那么下次再从buffer里取数据时，就要移动kHeaderSize + length大小的偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip physical record that started before initial_offset_</span></span><br><span class="line">    <span class="keyword">if</span> (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length &lt;</span><br><span class="line">        initial_offset_) &#123;</span><br><span class="line">      result-&gt;clear();</span><br><span class="line">      <span class="keyword">return</span> kBadRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *result = Slice(header + kHeaderSize, length); <span class="comment">// 本次读取到的record</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>ReadPhysicalRecord(&amp;fragment)</code>的逻辑就是每次从buffer中读取一条记录返回，如果buffer中没有数据了，就重新读取一个块。可见leveldb使用块方式组织log文件，可以减少读取时的I/O次数。</p>

    
  </div>
  <footer>
    
      
  <div class="categories">
    <a class="categories-link" href="/categories/技术/">技术</a>
  </div>

      
  <div class="tags">
    <a class="tags-link" href="/tags/leveldb/">leveldb</a>
  </div>

    
  </footer>
</article>


</div>
  </div>
  <footer id="footer"><div class="footer-mask"></div>
<div class="copyright">
  &copy; 2018
  
    <a href="/">Dorothy Zhang</a>
  
  <div class="heartbeat"></div><div class="heartbeat"></div>
  <div class="heartbeat float"></div>
</div>
<script>
  // heartbeart forcetouch
  var heartEl1 = document.querySelector('.heartbeat:first-of-type')
  var heartEl2 = document.querySelector('.heartbeat:nth-child(3)')
  var heartFloat = document.querySelector('.heartbeat.float')

  function prepareForForceClick(event) {
    event.preventDefault();
  }

  function enterForceClick(event) {
  }

  function endForceClick(event) {
    heartFloat.style.transform = 'scale(0)';
  }

  function forceChanged(event) {
    heartFloat.style.transform = 'scale(' + 8*event.webkitForce + ')';
  }

  function setupForceClickBehavior(someElement)
  {
    someElement.addEventListener("webkitmouseforcewillbegin", prepareForForceClick, false);
    someElement.addEventListener("webkitmouseforcedown", enterForceClick, false);
    someElement.addEventListener("webkitmouseforceup", endForceClick, false);
    someElement.addEventListener("webkitmouseforcechanged", forceChanged, false);
  }

  setupForceClickBehavior(heartEl1);
  setupForceClickBehavior(heartEl2);

  heartFloat.addEventListener('click', function(){
    heartFloat.style.transform = 'scale(0)'
  }, false)
</script>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>


  <div class="footer-mask"></div>
</body>
</html>
